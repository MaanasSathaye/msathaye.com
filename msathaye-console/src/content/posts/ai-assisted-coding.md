---
title: 'Some Thoughts on AI-Assisted Programming'
date: 2025-04-14
topic: 'engineering'
description: 'A humanistic evaluation of AI-assisted programming from a jaded engineer'
---

When I say "AI-Assisted Programming", I'm talking specifically about AGI assistance. My general thoughts on AI for *most* applications in enterprise software are articulated well by this infamous [blog](https://ludic.mataroa.blog/blog/i-will-fucking-piledrive-you-if-you-mention-ai-again/) post. This is a highly contentious topic right now, but it's one I'm not seeing enough humanistic evaluations on. Here's a take from a jaded engineer.

## Learning from High Performance Elsewhere

There are many ways to explain this point, but the one that I think is the easiest to understand, and the one I can relate to the most, is sports performance. No athlete on this planet performs at 100% for 365 days a year. Strength athletes use periodization to maximize training adaptations and minimize injury risk. NBA Teams are increasingly load managing to keep their stars healthy for deep playoff runs.

But, good luck telling your employer that you're "load managing" this week.<sup>*</sup> And that's my point. It's unrealistic to expect any engineer to work at 100% efficacy for 320+ days out of the year. Like athletes, our readiness for problem-solving undulates. Long stretches of unmotivated, uninspired work can be "averaged out" by copilots, letting you find the magic again when you're ready. Code quality is an extremely valid concern, but it's less of a concern for someone with the years of experience who has the wisdom and keen eye to rule out poor suggestions from LLMs. "The scenario where you describe acceptable llm use is known as burnout" well, yes. But the cure to burnout is a break from your job or programming in general, and some people simply can't afford that (due to lack of PTO or otherwise). Therefore, I think it's fair to say that copilot programming raises the baseline output of a salaried engineer however you choose to measure it.

> *<sup>\*</sup> To be clear, a version of "load managing" exists - explicitly lighter workload days. I'd highly recommend you try these with your employer. But, they're not "restful". If anything, they're tiny morale boosts that help engineers fend off burnout or imposter syndrome.*

## Forgive Me, Guido, For I Have Sinned

Confession time: I don't like Python. I have no qualms with the authors and maintainers, but I believe the way the ecosystem has evolved is an anti-pattern to deploying resilient, maintainable, and efficient services. Important context here: I'm a Golang/Rust guy. Python burns (and bums) me out quicker than any other language, and in this specific scenario, I believe copilot programming is a great way for me to continue solving business problems for my employer at minimal risk to my sanity.<sup>*</sup>

> *<sup>\*</sup> Senior engineers, yes, this is a skill issue. I will be the first to admit it. But of all the skills in my life I could sharpen (and all the time I could spend sharpening them), Python is at the bottom of the list. That's personal preference, and that's OK. More research on [Use It or Lose It](https://www.science.org/doi/10.1126/sciadv.ads1560) is coming out, and I'm far more afraid of losing other skills than I am in missing out on Python expertise.*

## "Copilot Pair Programming is just a new skill."

This is the argument that drives me insane. Let's take this step by step (pun intended). No skill worth learning is free lunch; you must put in the reps! Now, ask anyone that's worked on perfecting their craft. There's no 'faking' the work. You have to find ways to enjoy it. You compete with yourself to be better than you were yesterday, or last week, or last month. You compete with your peers. You document your learnings. You sacrifice. But when you love what you do, you learn to love progressing your skill, hitting milestones, 'leveling up'. I'm a strong believer in "how you do one thing is how you do everything". In other words, getting good at one skill helps you get good at another skill. Now let's think about the original context. Is prompting a skill you really want to improve on? Is a "prompt engineer" role something you want to put in the hours to distinguish yourself for? How does understanding the best way to communicate with this human-made, mostly black box system help you in other areas of your life? If you're going to say 'it helps me communicate', I dare you to look at the last 100 request logs with your copilot. How many frustrated cap locks arguments did you initiate? But, I digress. Do you see the point? I also find that the people who cite this argument are also the first ones to tout that "software engineering is dead". Have you considered that the best prompt engineer is potentially a machine?

## Virtue Signaling

Otherwise known as "all PR is good PR". This is a point Twitter-heads have pointed out already, but if a CEO is posting about how "AGI [will replace all swes, increases productivity by 1000x, magic-8-ball-ai-bullishness-of-choice] please acknowledge the vested interest and also check the job boards of said CEO's company. Please note this is distinctly different than saying 'I'm betting against this person', because that's also simply not true. Many of the established companies adding/pivoting-to AGI will find ways to survive long after all degrees of AI adoption, including replacing junior engineers. The workforce will continue to have to upskill, just like generations prior.

## Conclusion

AGI has lowered the threshold for efficiency. I don't think anybody's arguing with that. But, it hasn't stunted human ingenuity or creativity. If you're salaried and your organization supports AI assistance, you will be perceived (for better or worse) as a more consistent and efficient engineer if you're using AGI. But that doesn't mean you're a 10x/100x/1000x engineer (and since you're losing the reps, you could actually be worse). Stay in the programming gym as much as you can to continue to upskill yourself. It's never been more important than now.
